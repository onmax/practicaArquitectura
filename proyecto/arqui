* Inicializa el SP y el PC
**************************
        ORG     $0
        DC.L    $8000           * Pila
        DC.L    INICIO          * PC

        ORG     $400
        tam_bf  EQU     #2001
        *Declaración de buffers
        bra:    DS.B    tam_bf
        brb:    DS.B    tam_bf
        bta:    DS.B    tam_bf
        btb:    DS.B    tam_bf

        *Punteros de A

            *Recepción
            bra_i:          DS.B  4
            bra_e:          DS.B  4
            bra_bas:        DS.B  4 


            *Transmisión
            bta_i:          DS.B  4
            bta_e:          DS.B  4
            bta_bas:        DS.B  4 

        *Punteros de B

            *Recepción
            brb_i:          DS.B  4
            brb_e:          DS.B  4
            brb_bas:        DS.B  4
            
            
            *Transmisión 
            btb_i:          DS.B  4
            btb_e:          DS.B  4
            btb_bas:        DS.B  4 

* Definici?n de equivalencias
***************************************
*********************************

***Para A - Tabla pg.27***
MR1A    EQU     $effc01       * de modo A (escritura)
MR2A    EQU     $effc01       * de modo A (2? escritura)
SRA     EQU     $effc03       * de estado A (lectura)
CSRA    EQU     $effc03       * de seleccion de reloj A (escritura)
CRA     EQU     $effc05       * de control A (escritura)
TBA     EQU     $effc07       * buffer transmision A (escritura)
RBA     EQU     $effc07       * buffer recepcion A  (lectura)

***Para B - Tabla pg.27***
MR1B    EQU     $effc11       * de modo B (escritura)
MR2B    EQU     $effc11       * de modo B (2? escritura)
SRB     EQU     $effc13       * de estado B (lectura)
CSRB    EQU     $effc13       * de seleccion de reloj B (escritura)
CRB     EQU     $effc15       * de control B (escritura)
RBB     EQU     $effc17       * buffer recepcion B  (lectura)
TBB     EQU     $effc17       * buffer transmision B (escritura)

*ambas. Ver tabla pg.37
ACR     EQU     $effc09       * de control auxiliar
IMR     EQU     $effc0B       * de mascara de interrupcion A (escritura)
ISR     EQU     $effc0B       * de estado de interrupcion A (lectura)
IVR     EQU     $effc19       * de control auxiliar




*CPIMR:  DC.B    0



**************************** INIT *************************************************************
INIT:
        MOVE.B          #%00010000,CRA      * Reinicia el puntero MR1
        MOVE.B          #%00000011,MR1A     * 8 bits por caracter y solicita interrupcion
        MOVE.B          #%00000011,MR1B     * 8 bits por caracter y solicita interrupcion
        MOVE.B          #%00000000,MR2A     * Eco desactivado.
        MOVE.B          #%00000000,MR2B     * Eco desactivado.
        MOVE.B          #%11001100,CSRA     * Velocidad = 38400 bps.
        MOVE.B          #%11001100,CSRB     * Velocidad = 38400 bps.
        MOVE.B          #%00000000,ACR      * Velocidad = 38400 bps.
        MOVE.B          #%00000101,CRA      * Transmision y recepcion activados. Full Duplex.
        MOVE.B          #%00000101,CRB      * Transmision y recepcion activados. Full Duplex.
        MOVE.B          #%00000000,ISR      * Activar máscara de interrupcion (lectura)
        MOVE.B          #%01000000,IVR      * Vector de interrupcion en 64 (decimal), 40(hexadecimal).
                                            * RTI habría que colocarlo en => 64 x 4 = 256 (decimal) = 100(hexadecimal)
        **NOTA: Creemos que hay que ir cambiando ISR y IMR

        *INICIALIZACIÓN DE PUNTEROS

        MOVE.L  #bra, bra_escritura
        MOVE.L  #bra, bra_lectura
        MOVE.L  #$BD0, bra_bas
        

        MOVE.L  #bta, bta_escritura
        MOVE.L  #bta, bta_lectura
        MOVE.L  #$13A0, bta_bas
        

        MOVE.L  #brb, brb_escritura
        MOVE.L  #brb, btb_lectura
        MOVE.L  #$1B70, brb_bas
        

        MOVE.L  #btb, btb_escritura
        MOVE.L  #btb, btb_lectura
        MOVE.L  #$2340, btb_bas
        

        RTS
**************************** FIN INIT **********************************************************




**************************** RTI ************************************************************
**************************** FIN RTI ********************************************************




**************************** PRINT ************************************************************
PRINT:  RTS

**************************** FIN PRINT ********************************************************






**************************** SCAN ************************************************************
SCAN:     RTS
**************************** FIN SCAN ********************************************************






**************************** LEERCAR ************************************************************
LEERCAR:    MOVE.L      #0,A0              *Inicializamos a 0 --> A0
            MOVE.L      #0,A1              *Inicializamos a 0 --> A1
            MOVE.L      D0,D1               *Obtenemos de pila el buffer
            BTST        #0,D1              *Si el bit 0 == 0 --> Ir a linea A
            BEQ         LIN_A               *EOC --> Ir a B

LIN_B:      BTST        #1,D1              *Si el bit 1 == 0 --> Ir a recepcion
            BEQ         LC_BRB              *EOC --> Ir a transmision
            BSR         LC_BTB

LIN_A:      BTST        #1,D1              *Se repite el mismo esquema que LIN_B
            BEQ         LC_BRA
            BSR         LC_BTA



******Buffer transmision A******           *cont_ta,bta_e,btb

LC_BTA:     MOVE.L      cont_ta,A0         *Obtener direccion del contador 
            MOVE.L      bta_e,A1           *Obtener puntero de extracción,que apunta al caracter a leer
            MOVE.L      btb, A2            *La direccion de btb se pasa a A2
            MOVE.L      (A0),D1            *Obtener contenido del contador en D1
            CMP.L       #0,D1              *Comprobamos que el contador no sea 0 (.length en java),es decir,que no este vacio
            BEQ         B_EMPTY            *Salto en caso de que este vacio
            MOVE.L      bta_e,A1           *Obtener puntero de extracción,que apunta al caracter a leer
            MOVE.L      (A1),D0            *Metemos el carácter en D0
            MOVE.L      #0,(A1)+           *Ponemos la posicion liberada a null e incrementamos el puntero al siguiente caracter
            MOVE.L      A1,bta_e           *Actualizamos la posicion del puntero
            SUB.L       #1,D1              *Reducimos en 1 la cantidad de elementos en el buffer
            MOVE.L      D1,cont_ta         *Actualizamos el valor del contador
            CMP.L       A1,A2              *Comprobamos si el puntero ha llegado al final del buffer
            BEQ         BTA_INI            *En caso de que asi sea,toma el salto
            RTS
BTA_INI:    MOVE.L      #bta,bta_e         *Apuntamos bra_e a bta(principio del buffer)
            RTS

*******Buffer recepcion A*******           *cont_ra,bra_e,brb
LC_BRA:     MOVE.L      cont_ra,A0
            MOVE.L      bra_e,A1
            MOVE.L      brb, A2
            MOVE.L      (A0),D1
            CMP.L       #0,D1
            BEQ         B_EMPTY  
            MOVE.L      (A1),D0
            MOVE.L      #0,(A1)+
            MOVE.L      A1,bra_e
            SUB.L       #1,D1
            MOVE.L      D1,cont_ra
            CMP.L       bra_e,brb
            BEQ         BRA_INI
            RTS
BRA_INI:    MOVE.L      #bta,bra_e
            RTS
********************************


******Buffer transmision B******           *cont_tb,btb_e,fin_bff
LC_BTB:     MOVE.L      cont_tb,A0
            MOVE.L      (A0),D1
            CMP.L       #0,D1
            BEQ         B_EMPTY
            MOVE.L      btb_e,A1
            MOVE.L      (A1),D0
            MOVE.L      #0,(A1)+
            MOVE.L      A1,btb_e
            SUB.L       #1,D1
            MOVE.L      D1,cont_tb
            CMP.L       btb_e,fin_bff
            BEQ         BTB_INI
            RTS
BTB_INI:    MOVE.L      #bta,bra_e
            RTS

*******Buffer recepcion B*******           *cont_rb,brb_e,bta
LC_BRB:     MOVE.L      cont_rb,A0
            MOVE.L      (A0),D1
            CMP.L       #0,D1
            BEQ         B_EMPTY
            MOVE.L      brb_e,A1
            MOVE.L      (A1),D0
            MOVE.L      #0,(A1)+
            MOVE.L      A1,brb_e
            SUB.L       #1,D1
            MOVE.L      D1,cont_rb
            CMP.L       brb_e,bta
            BEQ         BRB_INI
            RTS
BRB_INI:    MOVE.L      #bta,bra_e
            RTS
********************************

B_EMPTY:    MOVE.L      #$FFFFFFFF,D0
            RTS
**************************** FIN LEERCAR ********************************************************


**************************** ESCCAR ************************************************************
ESCCAR:     MOVE.L      D0,D2           *Buffer a D2
            MOVE.L      #0,D3           *D3 a cero
            MOVE.B      D1,D3           *Caracter a D3
            MOVE.L      #0,A0           *A0 a cero
            MOVE.L      #0,A1           *A1 a cero
            BTST        #0,D2           *Si el bit 0 == 0 --> Ir a linea A
            BEQ         LIN_A            *EOC --> Ir a B

LIN_B:      BTST        #1,D2           *Si el bit 1 == 0 --> Ir a recepcion
            BEQ         LC_BRB           *EOC --> Ir a transmision
            BSR         LC_BTB

LIN_A:      BTST        #1,D2            *Se repite el mismo esquema que LIN_B
            BEQ         LC_BRA
            BSR         LC_BTA


******Buffer transmision A******
LC_BTA:     MOVE.L      bra_escritura,A0    
            MOVE.L      bra_lectura,A1
            MOVE.L      bra_bas,A2
            MOVE.L      A0,D4               *D4 es escritura
            MOVE.L      A1,D5               *D5 es lectura
            SUB.L       D5,D4               *Escritura - lectura
            CMP         #0,D4               *Si = 0, caso de buffer lleno o vacio
            BEQ         CAS_ESP             *Dicho caso se trata en CAS_ESP
ESCRIB:     MOVE.L      D3,(A0)+            *Escribimos el carcater en el buffer y postincremento del puntero de escritura
            CMP.L       A2,A0               *Comprobamos si el puntero apunta a basura(el final)
            BEQ         VUELTA              *Si apunta, el puntero vuelve al principio
            MOVE.L      A0,bra_escritura    *Se actualiza el puntero de escritura
            RTS
VUELTA:     MOVE.L      bra,A3              *A3 <- Puntero inicio 
            MOVE.L      A3,A0               *
            MOVE.L      A0,bra_escritura
            MOVE.L      #1,(A2)
            RTS
CAS_ESP:    CMP.L       (A2),#1
            BNE         ESCRIB 
            MOVE.L      #$FFFFFFFF,D0
            RTS       
*******Buffer recepcion A*******
LC_BRA:     MOVE.B      bra_i, D1           *Lo mismo que LC_BTA
            MOVE.B      bra_f, D2
            CMP         D1, D2
            BEQ         LC_CERO
            MOVE.L      D1, LC_CHAR
            MOVE.L      LC_CHAR, D0
********************************


******Buffer transmision B******
LC_BTB:     MOVE.B      btb_i, D1          *Lo mismo que LC_BTA
            MOVE.B      btb_f, D2
            CMP         D1, D2
            BEQ         LC_CERO
            MOVE.L      D1, LC_CHAR
            MOVE.L      LC_CHAR, D0

*******Buffer recepcion B*******
LC_BRB:     MOVE.B      brb_i, D1          *Lo mismo que LC_BTA
            MOVE.B      brb_f, D2
            CMP         D1, D2
            BEQ         LC_CERO
            MOVE.L      D1, LC_CHAR
            MOVE.L      LC_CHAR, D0
********************************

LC_LLENO:   MOVE.L      #$FFFFFFFF,D0
            RTS



ESCCAR:  RTS

**************************** FIN ESCCAR ********************************************************





**************************** LINEA ************************************************************
LINEA:  RTS

**************************** FIN LINEA ********************************************************




**************************** PROGRAMA PRINCIPAL **********************************************
INICIO: BSR             INIT                * Inicia el controlador

        BSR             LEERCAR               * Recibe la linea
        *ADD.L           #4,A7               * Restaura la pila
        *MOVE.L          #$5000,-(A7)        * Prepara la direcci?n del buffer
        *BSR             PRINT               * Imprime l?nea
        *ADD.L           #4,A7               * Restaura la pila
BRA		  OTRO

         BREAK
**************************** FIN PROGRAMA PRINCIPAL ******************************************
